'''アルゴリズムと工夫点(Brute Force 1/CPU: 56 ms Memory: 76612 KB  Length: 182 B)
この問題は次のように言い換えることができる．「1<=a<=N,1<=b<=Nの条件で，a+b<=Sとなる(a,b)の総数を数え上げなさい．」
今回は問題の制約的に愚直に全探索してもO(N^2)≒10^6 となり間に合う．
しかし，以下の様な入力が与えられると，1秒以上処理時間がかかってしまうのではないだろうか．
----------
入力例1
1000000 523400

出力例1
136973518300

入力例2
10000000 12345678

出力例2
70705673532997
----------
そこで，問題の制約が「1<=N<=10000000,1<=S<=20000000」だった場合も高速に動作するアルゴリズムを考える．
今回の問題は(a,b)という2つの変数を考える必要があった．
aの値が固定された時，a+b<=Sを満たすbの最大値bMaxとすると，aの増加に対してbMaxは単調に減少する．
つまり，a=xの時bMax=yならば，a=x+1の時，bMax<yとなる．
よって(a,b)=(1,n)でからスタートし，aが固定された時のbMaxをまず求める．
bの値が[a,bMax]の範囲の時，条件a+b<=Sを満たす．この時，a!=bの時は，a>bの場合も考えなければならないから，数え上げの個数を2倍にする．
従って，(bMax-a)*2+1(a=bの時の1通り)パターン数，a+b<=Sを満たす．これで，aの値が固定された時のパターン数は数え上げることができるから，1<=a<=nの範囲で動かして全パターン数を数え上げる．
これは「尺取り法」という．最悪計算量は O(N)≒10^7 となり，高速．
'''
n,s=map(int,input().split())
ans=0
b=n
for r in range(1,n+1):
    while r<=b and r+b>s:
        b-=1
    if r<=b:
        ans+=2*(b-r)+1
    else :
        break
print(ans)